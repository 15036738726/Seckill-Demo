

接入层 不要做大量IO


锁和事务的顺序一定要注意  加锁加到事务外部才可以

行锁控制并发,
只能在并发不高的情况下完,如果并发很高,就不能这样玩,因为把压力都给到数据库了
我们更加希望压力在程序中放着





Redisson的看门狗机制
https://blog.csdn.net/justlpf/article/details/130677262



方案一:存在并发问题
消费者端使用的是并发消费模式,40个线程去执行消费这些消息,
某一时刻假设库存此时剩余2,A B线程同时执行查询商品的操作,然后取出库存2,扣减-1,然后更新到数据库,那么最终生成了2份订单,但是库存还剩余1

改造:
把代码用锁包裹起来 但是还是存在线程安全问题
https://blog.csdn.net/fengzongfu/article/details/103644772


Jmeter压测
添加线程组
添加取样器HTTP 请求
添加 监听器-汇总报告




TRUNCATE `order`;


UPDATE `seckill_test`.`goods` SET `total_stocks` = 500  WHERE `id` = 1;
UPDATE `seckill_test`.`goods` SET `total_stocks` = 10  WHERE `id` = 2;

http://localhost:8081/seckill?goodsId=18


========================代码问题整理================================
        /**
         * 问题一:存在并发问题 需要加锁
         * 消费者端使用的是并发消费模式,40个线程去执行消费这些消息,
         * 某一时刻假设库存此时剩余2,A B线程同时执行查询商品的操作,然后取出库存2,扣减-1,然后更新到数据库,那么最终生成了2份订单,但是库存还剩余1
         *
         *
         *
         * 问题二: 加锁位置问题, 加在事务内  还是加在事务外?  加在事务外部
         * 若加载事务内  库存1000  则如下:
         * -------
         * 开始事务
         * 加锁
         * 执行业务代码
         * 释放
         * 提交事务
         * ----------
         * 假设1: mysql事务隔离级别为默认  可重复读(mysql默认) RR
         * 因为是先开事务在开锁,AB两个线程同时开启了事务,对于A和B来说,此时数据库中数据 相当于每人都拿取了一份镜像 两份都一样
         * 此时假设A抢到锁,然后执行业务代码,库存数据修改(-1),无论最终A线程事务提交后B线程去执行,还是没有提交B就抢到了锁资源进行执行,对于B来说
         * 它拿的数据始终是开启事务那一刻从数据库中拿到的镜像数据,还是1000
         *
         * 假设2: mysql事务隔离级别设置为读提交RC(一个事务内,可以读取都另外一个事务提交的数据)
         * 这种也不行,假设A线程释放锁之后,还没来得及提交事务,此时B获取了锁资源,进行数据读取,那么因为A线程的数据还没有
         * 提交到数据库,所以B线程在执行业务代码时拿到的数据也是没有被修改的数据
         *
         * 问题三:集群问题
         * 即使做到了线程安全(单机版没问题),但无法做集群 ,多台机器JVM不共享, synchronized (this) {锁不住,真正业务场景下
         * 肯定消费者是多台机器集群部署,然后去消费消息的
         */


		 /**
         * 行锁(innodb)方案 mysql  能够解决分布式情况的数据安全问题  但不适合用于并发量特别大的场景
         * 因为压力最终都在数据库承担
         */




		/**
		 * Duration.ofSeconds(30) 这个时间可以设置的很大,但是不能设置的很小,一般要大于业务代码执行时间
		 * 假设goodsService.realSeckillCaseC(userId, goodsId);执行完成平均需要2秒,那么设置过期时间一定要>2秒,否则锁不住,引起线程安全问题
		 * 可以了解一下 Redis：Redisson分布式锁的锁续期原理
		 * 首先它对锁的控制不是起决定性作用,因为正常情况下,锁都是在finally中手动删除的
		 * 如果程序在运行期间，机器突然挂了(当前机器中的A线程在执行的过程中卡住了)，代码层面没有走到 finally 代码块，即在宕机前，锁并没有被删除掉
		 * 那么没有过期时间的话,锁得不到释放,导致的结果就是别的正常的机器都无法执行消费功能,所以分布式锁一定要加锁过期时间,时间可以设置的大一点都无所谓
		 */